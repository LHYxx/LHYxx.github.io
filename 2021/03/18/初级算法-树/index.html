<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content>
    <link rel="shortcut icon" href="/img/book.png">
    <title>初级算法|树-小新xx</title>
    
        
            <link href="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">
            <link href="https://cdn.bootcss.com/academicons/1.8.6/css/academicons.min.css" rel="stylesheet">
            <link href="https://cdn.bootcss.com/font-awesome/5.9.0/css/all.min.css" rel="stylesheet">
            <link href="https://cdn.bootcss.com/animate.css/3.7.2/animate.min.css" rel="stylesheet">
        
    
    <link rel="stylesheet" href="/css/adagio.css">

    <style type="text/css">
        .jumbotron{
            background: url();
            background-repeat: no-repeat;
            background-size: 100% 100%;
        }
        .tag-list{
            font-weight: bold;
            font-size: 200;
            color: red;
        }
    </style>

<!-- 下面是对mathjax的设置 -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true,
      linebreaks: {automatic: ['\\']}
    },
    "HTML-CSS": { linebreaks: { automatic: true } },
         SVG: { linebreaks: { automatic: true } }
  });
</script>



</head>
<!-- <body style="background: url('/') no-repeat; background-size: 100%;"> 带背景-->
<body>
    <div class="container-fluid">
    <nav class="nav">
        <div class="collapse navbar-collapse" id="navbar-sm">
            
            
            <div class="navbar-nav">
                <a href="/index.html" class="nav-item nav-link">主页</a>
            </div>
            
            <div class="navbar-nav">
                <a href="/others/aboutme.html" class="nav-item nav-link">LHYxx</a>
            </div>
            
        </div>
    </nav>
</div>

<div class="d-flex d-md-none" style="width: 100%; background-color: #e9ecef">
    <div class="nav">
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-sm"
            aria-expanded="false" aria-label="Toggle Navigation">
            <i class="fas fa-bars fa-lg"></i>
        </button>
    </div>
    <nav class="navbar ml-auto">
        <a class="navbar-brand" href="/">
            
            LHYxx
            
        </a>
    </nav>
</div>


<div class="container d-none d-md-block my-navbar">
    <nav class="navbar navbar-expand-sm navbar-light bg-transparent">
        <a class="navbar-brand " href="/">
            
            LHYxx
            
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav"
            aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav">
                
                <li class="nav-item pl-2 pr-2 ">
                    <a class="nav-link" href="/index.html">主页</a>
                </li>
                
                <li class="nav-item pl-2 pr-2 ">
                    <a class="nav-link" href="/others/aboutme.html">LHYxx</a>
                </li>
                
            </ul>
        </div>
    </nav>
</div>




    <div class="jumbotron jumbotron-fluid">
<!-- <div class="jumbotron jumbotron-fluid" style="background-image: url()"> -->
    <div class="container" >
        
        <h1 class="mt-4 article-title page-title" style="font-weight: bold; color: black">初级算法|树</h1>
        
        <p class="lead text-gray mt-3" style="color: black">By 小新; Published on 2021-03-18</p>
        
        <div class="tags">
            <ul class="tag-list">
                
                <li class="tag-list-item">
                    <a class="tag-list-link" href="/tags/leetcode/">leetcode</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</div>
    <div class="container">
        <div class="row">
            <div class="col-md-9 pt-2">
                <div class="row">
                    <div class="col-12">
                        <main>
                            <article class="article-text page-content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>二叉树的最大深度</li>
<li>二叉树的层序遍历</li>
<li>验证二叉搜索树</li>
<li>对称二叉树</li>
<li>将有序数组转换为二叉搜索树</li>
<li>783 二叉搜索树节点最小距离</li>
</ul>
<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 设置边界条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span>  <span class="comment"># 最终深度就是左子树和右子树中长度最大的加一</span></span><br></pre></td></tr></table></figure>

<h4 id="BFS解法，数层数"><a href="#BFS解法，数层数" class="headerlink" title="BFS解法，数层数"></a>BFS解法，数层数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果输入为空，则深度为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        lst = []  <span class="comment"># 建一个队列</span></span><br><span class="line">        lst.append(root)  <span class="comment"># 根节点入队</span></span><br><span class="line">        depth = <span class="number">0</span>  <span class="comment"># 记录深度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> len(lst)&gt;<span class="number">0</span>:  <span class="comment"># 当队列不为空</span></span><br><span class="line">            size = len(lst)  <span class="comment"># 这一层有多少个节点</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(size):  <span class="comment"># 遍历这一层的节点，将孩子们都入队</span></span><br><span class="line">                top = lst.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> top <span class="keyword">and</span> top.left:</span><br><span class="line">                    lst.append(top.left)</span><br><span class="line">                <span class="keyword">if</span> top <span class="keyword">and</span> top.right:</span><br><span class="line">                    lst.append(top.right)</span><br><span class="line">            depth += <span class="number">1</span>  <span class="comment"># 这一层遍历结束，深度加一</span></span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>

<h4 id="DFS解法，双栈"><a href="#DFS解法，双栈" class="headerlink" title="DFS解法，双栈"></a>DFS解法，双栈</h4><p>深度优先遍历，只需要将队列变为栈即可。使用两个栈lst和level，lst保存节点，level保存节点对应的层数，lst和level同时出栈入栈以保证元素对应一致。然后深度遍历树，记录最大的层数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        lst = []</span><br><span class="line">        lst.append(root)  <span class="comment"># 根节点入队</span></span><br><span class="line">        level = []</span><br><span class="line">        level.append(<span class="number">1</span>)  <span class="comment"># 根节点对应的层数（1）入队</span></span><br><span class="line">        depth = <span class="number">1</span>  <span class="comment"># 记录最大深度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> len(lst)&gt;<span class="number">0</span>:  <span class="comment"># 当队列不为空</span></span><br><span class="line">            top = lst.pop(<span class="number">-1</span>)  <span class="comment"># 栈顶节点元素</span></span><br><span class="line">            top_level = level.pop(<span class="number">-1</span>)  <span class="comment"># 栈顶节点对应的层数</span></span><br><span class="line">            depth = max(depth, top_level)  <span class="comment"># 记录最大深度</span></span><br><span class="line">            <span class="keyword">if</span> top <span class="keyword">and</span> top.left:  <span class="comment"># 将当前节点的孩子们都入栈</span></span><br><span class="line">                lst.append(top.left)</span><br><span class="line">                level.append(top_level+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> top <span class="keyword">and</span> top.right:</span><br><span class="line">                lst.append(top.right)</span><br><span class="line">                level.append(top_level+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> depth  <span class="comment"># 最后返回最大深度</span></span><br></pre></td></tr></table></figure>

<h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        lst = []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> lst</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> len(queue)&gt;<span class="number">0</span>:</span><br><span class="line">            size = len(queue)</span><br><span class="line">            cur_lst = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">                top = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> top:</span><br><span class="line">                    cur_lst.append(top.val)</span><br><span class="line">                    <span class="keyword">if</span> top.left:</span><br><span class="line">                        queue.append(top.left)</span><br><span class="line">                    <span class="keyword">if</span> top.right:</span><br><span class="line">                        queue.append(top.right)</span><br><span class="line">            lst.append(cur_lst)</span><br><span class="line">        <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure>

<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>

<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><p>这道题一开始非常容易写出一个错误版本。<br>如果当前节点有左孩子，判断左孩子是否小于当前节点。<br>如果当前节点有右孩子，判断右孩子是否大于当前节点。<br>递归判断当前节点的左子树是否满足；<br>递归判断当前节点的右子树是否满足。<br>如果上述条件全满足，则说明是一个二叉搜索树。<br><strong>上面的这个版本是错误的。</strong><br>因为该方法比较了当前节点与左右孩子的大小，但是没有比较当前节点与孩子的孩子的大小。因此对于上面的示例2输入，会判断为true。</p>
<p>由于要保证左子树的全部值小于当前节点，右子树的全部值大于当前节点，因此，对于每个节点的值都有一个取值范围，如果落在这个取值范围之内，则满足二叉搜索树，否则不满足。<br>令根节点的取值范围为$[-2^31-1, 2^31]$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(root, minval, maxval)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 递归边界</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> root.val&gt;minval <span class="keyword">and</span> root.val&lt;maxval:  <span class="comment"># 如果当前节点在取值范围内</span></span><br><span class="line">                <span class="keyword">return</span> isValid(root.left, minval, root.val) <span class="keyword">and</span> isValid(root.right, root.val, maxval)  <span class="comment"># 左右子树都满足则返回True，有不满足的则返回False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> isValid(root, <span class="number">-2</span>**<span class="number">31</span><span class="number">-1</span>, <span class="number">2</span>**<span class="number">31</span>)</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历递归法"><a href="#中序遍历递归法" class="headerlink" title="中序遍历递归法"></a>中序遍历递归法</h4><p>由二叉搜索树的性质可知，如果中序遍历二叉搜索树，得到的序列一定是有序的。<br>因此，在中序遍历二叉树的过程中，判断当前节点是否比上一个节点大即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pre = <span class="literal">None</span>  <span class="comment"># 用来保存前一个节点的全局变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 递归边界</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isValidBST(root.left):  <span class="comment"># 判断左子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> self.pre <span class="keyword">and</span> root.val &lt;= self.pre.val:  <span class="comment"># 当前节点如果小于等于前一个节点，则不满足</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.pre = root  <span class="comment"># 前一个节点设为当前节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isValidBST(root.right):  <span class="comment"># 判断右子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h4 id="中序遍历非递归法"><a href="#中序遍历非递归法" class="headerlink" title="中序遍历非递归法"></a>中序遍历非递归法</h4><p>二叉树的中序遍历还可以用非递归的方法来实现。因为递归法实际上就是用到了调用栈结构，因此我们可以用一个栈结构来模拟。<br>中序遍历的话，基本思想就是，对于当前节点，先访问其左子树，然后访问本身，然后访问右子树。所以按照这个顺序入栈每一个节点，模拟递归时的调用顺序即可。<br>首先，二叉树的中序遍历非递归写法代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        stack = []  <span class="comment"># 栈</span></span><br><span class="line">        cur = root  <span class="comment"># 当前节点</span></span><br><span class="line">        <span class="keyword">while</span> len(stack)&gt;<span class="number">0</span> <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur:  <span class="comment"># 不断将左孩子入栈</span></span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 该子树的所有左孩子都入栈之后，取栈顶元素</span></span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            print(cur.val)  <span class="comment"># 访问该元素</span></span><br><span class="line">            cur = cur.right  <span class="comment"># 处理其右子树</span></span><br></pre></td></tr></table></figure>

<p>然后放到这个题中来说，就需要在每一步判断当前节点是否比前一个节点大，以判断是否是有序的，进而判断是否是二叉搜索树。<br>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        stack = []</span><br><span class="line">        cur = root  <span class="comment"># 保存当前节点</span></span><br><span class="line">        pre = <span class="literal">None</span>  <span class="comment"># 保存前一节点</span></span><br><span class="line">        <span class="keyword">while</span> len(stack)&gt;<span class="number">0</span> <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> pre <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 如果有前一节点，则与其比较</span></span><br><span class="line">                <span class="keyword">if</span> cur.val&lt;=pre.val:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            pre = cur  <span class="comment"># 当前节点变为前一节点</span></span><br><span class="line">            cur = cur.right  <span class="comment"># 当前节点转移</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><h4 id="层次遍历解法"><a href="#层次遍历解法" class="headerlink" title="层次遍历解法"></a>层次遍历解法</h4><p>这种方法是看到这道题之后第一反应想出来的解法。。。虽然感觉不是那么主流，但是至少也还可以实现，而且不用递归方法。可能是因为最近做的层次遍历的题比较多，对层次遍历比较熟悉吧。<br>基本思想就是，层次遍历二叉树，然后其中的空位置也要补上None，然后判断每一层的内容正反是否相同（类似于判断是否是回文）。如果某一层不满足，则说明不对称。<br>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> len(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            lst = []</span><br><span class="line">            size = len(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">                top = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> top:  <span class="comment"># 对于每个节点需要考虑是不是空节点，因为我们把空节点也补充进来了</span></span><br><span class="line">                    lst.append(top.val)</span><br><span class="line">                    queue.append(top.left)</span><br><span class="line">                    queue.append(top.right)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    lst.append(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> lst != lst[::<span class="number">-1</span>]:  <span class="comment"># 如果这一层不是回文，那么不对称</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h4 id="递归解法-1"><a href="#递归解法-1" class="headerlink" title="递归解法"></a>递归解法</h4><p>对于一棵对称二叉树，其主要特征在于对称位置的元素相同。即对于对称位置的左右两个节点：<br>左节点 == 右节点<br>左节点的左孩子 == 右节点的右孩子<br>左节点的右孩子 == 右节点的左孩子<br>因此采用递归的实现方法代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, left, right)</span>:</span>  <span class="comment"># 递归检查函数</span></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果左右节点都是None，则对称</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 如果左右节点都不是None</span></span><br><span class="line">            <span class="comment"># 检查左节点是否等于右节点；左节点的左孩子是否等于右节点的右孩子；左节点的右孩子是否等于右节点的左孩子</span></span><br><span class="line">            <span class="keyword">return</span> self.check(left.left, right.right) <span class="keyword">and</span> self.check(left.right, right.left) <span class="keyword">and</span> left.val == right.val</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 否则一个为空一个不为空，则不对称</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.check(root.left, root.right)</span><br></pre></td></tr></table></figure>

<h4 id="非递归解法"><a href="#非递归解法" class="headerlink" title="非递归解法"></a>非递归解法</h4><p>思想和递归解法相同，只是将递归实现转变为了非递归实现。关键点在于每次入队对称位置的节点，然后每次出队两两比较即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root.left)</span><br><span class="line">        queue.append(root.right)</span><br><span class="line">        <span class="keyword">while</span> len(queue)&gt;<span class="number">0</span>:</span><br><span class="line">            left = queue.pop(<span class="number">0</span>)  <span class="comment"># 每次出队两个节点</span></span><br><span class="line">            right = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果都为None，则成立</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 如果都不为None，判断值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 否则一个为None一个不为None，不对称</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            queue.append(left.left)  <span class="comment"># 入队对称位置的子节点</span></span><br><span class="line">            queue.append(right.right)</span><br><span class="line">            queue.append(left.right)</span><br><span class="line">            queue.append(right.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。<br>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]</span><br><span class="line">解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line">   / \</span><br><span class="line"> -3   9</span><br><span class="line"> /   /</span><br><span class="line">-10 5</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line">   / \</span><br><span class="line"> -10   5</span><br><span class="line">    \   \</span><br><span class="line">    -3   9</span><br></pre></td></tr></table></figure>

<h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><h4 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h4><p>由于数组有序，因此我们可以每次选择中间的数值构建节点，然后剩下的节点分为了左半部分与右半部分，然后对于左右两部分，分别递归地调用这个过程，构建节点的左右子树。最终就会得到一个平衡的二叉搜索树。<br>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildBST</span><span class="params">(self, nums, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:  <span class="comment"># 要考虑好这里的边界条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = (left+right)//<span class="number">2</span></span><br><span class="line">        node = TreeNode(nums[mid])</span><br><span class="line">        node.left = self.buildBST(nums, left, mid<span class="number">-1</span>)</span><br><span class="line">        node.right = self.buildBST(nums, mid+<span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.buildBST(nums, <span class="number">0</span>, len(nums)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="783-二叉搜索树节点最小距离"><a href="#783-二叉搜索树节点最小距离" class="headerlink" title="783 二叉搜索树节点最小距离"></a>783 二叉搜索树节点最小距离</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个二叉搜索树的根节点 root ，返回 <strong>树中任意两不同节点值之间的最小差值</strong>。</p>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">    / \</span><br><span class="line">   2   6</span><br><span class="line">  / \</span><br><span class="line"> 1   3</span><br><span class="line">输入：root = [4,2,6,1,3]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     1</span><br><span class="line">    / \</span><br><span class="line">   0   48</span><br><span class="line">       / \</span><br><span class="line">      12  49</span><br><span class="line">输入：root = [1,0,48,null,null,12,49]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>二叉搜索树的特点是：左子树的任何值都小于当前值，右子树的任何值都大于当前值。<br>因此二叉搜索树中序遍历得到的是一个有序升序序列。</p>
<p>一开始的第一反应是，遍历一遍树，对每个节点计算当前节点与左孩子与右孩子的差，并用一个变量保存最小值。这样遍历一遍所有节点，就能得到最小的差值了。</p>
<p>上面的方法是错误的，大家不要模仿。。。。</p>
<p>因为二叉搜索树题目求的是<strong>任意两不同节点</strong>之间的最小差值。当前节点与左孩子的差并不一定是最小差值，因为左孩子的右孩子的值是大于左孩子的，因此当前节点与左孩子的右孩子的差值要更小一点。同理可以对应到右子树部分。</p>
<h4 id="每个节点挨个判断"><a href="#每个节点挨个判断" class="headerlink" title="每个节点挨个判断"></a>每个节点挨个判断</h4><p>对上面的方法稍微修改一下即可：对于当前节点，计算当前节点与左子树中最大值的差，计算当前节点与右子树的最小值的差，并取最小值。<br>因此需要设计两个函数，分别求当前树的最小值与最大值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDiffInBST</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getMinBST</span><span class="params">(root)</span>:</span>  <span class="comment"># 求以root为根节点的二叉搜索树的最小值</span></span><br><span class="line">            <span class="keyword">while</span> root.left:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getMaxBST</span><span class="params">(root)</span>:</span>  <span class="comment"># 求以root为根节点的二叉搜索树的最大值</span></span><br><span class="line">            <span class="keyword">while</span> root.right:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        minDif = <span class="number">2</span>**<span class="number">31</span>  <span class="comment"># 变量保存差的最小值</span></span><br><span class="line">        q = [root]  <span class="comment"># 队列，用于遍历树</span></span><br><span class="line">        <span class="keyword">while</span> len(q)&gt;<span class="number">0</span>:</span><br><span class="line">            top = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> top.left:  <span class="comment"># 如果有左孩子，则入队，并计算当前值与左子树中最大值的差</span></span><br><span class="line">                q.append(top.left)</span><br><span class="line">                minDif = min(minDif, abs(top.val-getMaxBST(top.left).val))</span><br><span class="line">            <span class="keyword">if</span> top.right:  <span class="comment"># 如果有右孩子，则入队，并计算当前值与右子树中最小值的差</span></span><br><span class="line">                q.append(top.right)</span><br><span class="line">                minDif = min(minDif, abs(top.val-getMinBST(top.right).val))</span><br><span class="line">        <span class="keyword">return</span> minDif</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历法"><a href="#中序遍历法" class="headerlink" title="中序遍历法"></a>中序遍历法</h4><p>因为二叉搜索树中序遍历是一个有序数列，因此差的最小值一定发生在两个相邻值之间。<br>我们可以对二叉搜索树进行中序遍历，得到一个有序数列，然后遍历数列，求最小差值。</p>
<p>另外，我们也可以在中序遍历的过程中计算相邻两个数之间的差值，这样一方面省去了保存数列的空间，同时也省去了遍历数组的过程，更加高效。只是需要在中序遍历的过程中增加一个变量<code>pre</code>来保存上一个节点的值。<br>下面代码是中序遍历迭代写法，当然也可以用中序遍历的递归写法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDiffInBST</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        minDif = <span class="number">2</span>**<span class="number">31</span></span><br><span class="line">        s = []  <span class="comment"># 栈，用于遍历树</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> len(s)&gt;<span class="number">0</span> <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur:  <span class="comment"># 所有左孩子入栈</span></span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            cur = s.pop(<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> pre:  <span class="comment"># 计算与前一节点的差值</span></span><br><span class="line">                minDif = min(abs(cur.val-pre.val), minDif)</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.right  <span class="comment"># 转移处理该节点的右子树</span></span><br><span class="line">        <span class="keyword">return</span> minDif</span><br></pre></td></tr></table></figure></article>
                        </main>
                        
                        
                    </div>
                </div>
                <div class="row mt-5 mb-5">
                    <div class="col-12">
                        <div class="row">
    <div class="col">
        <nav aria-label="paginator" class="paginator">
            <ul class="pagination d-none d-md-flex pagination-lg justify-content-center">
                <li class="page-item ">
                    <a class="page-link"
                        href="/2021/03/20/初级算法-字符串/"
                        aria-label="Previous">
                        <span aria-hidden="true">&laquo;
                            初级算法|字符串</span>
                        <span class="sr-only">Previous</span>
                    </a>
                </li>
                <li class="page-item ">
                    <a class="page-link"
                        href="/2021/03/17/中级算法-树和图/"
                        aria-label="Next">
                        <span
                            aria-hidden="true">中级算法-树和图
                            &raquo;</span>
                        <span class="sr-only">Next</span>
                    </a>
                </li>
            </ul>
            <ul class="pagination d-md-none justify-content-center">
                <li class="page-item ">
                    <a class="page-link"
                        href="/2021/03/20/初级算法-字符串/"
                        aria-label="Previous">
                        <span aria-hidden="true">&laquo;
                            初级算法|字符串</span>
                        <span class="sr-only">Previous</span>
                    </a>
                </li>
                <li class="page-item ">
                    <a class="page-link"
                        href="/2021/03/17/中级算法-树和图/"
                        aria-label="Next">
                        <span
                            aria-hidden="true">中级算法-树和图
                            &raquo;</span>
                        <span class="sr-only">Next</span>
                    </a>
                </li>
            </ul>
        </nav>
    </div>
</div>



                    </div>
                </div>
                <div class="row">
                    <div class="col-12">
                        <div id="vcomment"></div>
                    </div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="container pt-4 page-sidebar">
                    
                    <div class="row">
    <div class="col">
        <h6>APPLAUSE FOR ME</h6>
        <div id="applause-easy"></div>
    </div>
</div>
                    
                    <hr class="row">
                    <div class="row toc-container">
                        <div class="col-12">
                            <h6>NAVIGATION</h6>
                            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#目录"><span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树的最大深度"><span class="toc-text">二叉树的最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#题解"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#递归解法"><span class="toc-text">递归解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFS解法，数层数"><span class="toc-text">BFS解法，数层数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DFS解法，双栈"><span class="toc-text">DFS解法，双栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树的层序遍历"><span class="toc-text">二叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#题解-1"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#验证二叉搜索树"><span class="toc-text">验证二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#题解-2"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#递归法"><span class="toc-text">递归法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中序遍历递归法"><span class="toc-text">中序遍历递归法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中序遍历非递归法"><span class="toc-text">中序遍历非递归法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对称二叉树"><span class="toc-text">对称二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#题解-3"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#层次遍历解法"><span class="toc-text">层次遍历解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#递归解法-1"><span class="toc-text">递归解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非递归解法"><span class="toc-text">非递归解法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将有序数组转换为二叉搜索树"><span class="toc-text">将有序数组转换为二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#题解-4"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#递归法-1"><span class="toc-text">递归法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#783-二叉搜索树节点最小距离"><span class="toc-text">783 二叉搜索树节点最小距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#题解-5"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#每个节点挨个判断"><span class="toc-text">每个节点挨个判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中序遍历法"><span class="toc-text">中序遍历法</span></a></li></ol></li></ol></li></ol>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <footer>
    <div class="jumbotron jumbotron-fluid mb-0">
        <div class="container-fluid">
            <div class="col text-center">
                <div class="bottom-social">
                    <div class="row">
    <div class="col text-center">
        <ul class="list-inline">
            
            <li class="list-inline-item">
                
                <a href="https://github.com/LHYxx">
                    <span class="fa-stack fa-2x icon-link">
                        <i class="fas fa-circle fa-stack-2x"></i>
                        <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                    </span>
                </a>
                
            </li>
            
            <li class="list-inline-item">
                
                <a href="https://www.zhihu.com/people/zhihu_name">
                    <span class="fa-stack fa-2x icon-link">
                        <i class="fas fa-circle fa-stack-2x"></i>
                        <i class="fab fa-zhihu fa-stack-1x fa-inverse"></i>
                    </span>
                </a>
                
            </li>
            
        </ul>
    </div>
</div>

                </div>
                <p class="copyright text-muted">
                    Copyright &copy; 小新xx
                    <br>
                    感谢支持！
                    <br>
                    <a href="http://cs.scu.edu.cn/">海纳百川</a>, 
                    <a href="http://www.tju.edu.cn/">实事求是</a>.
                </p>
            </div>
        </div>
    </div>
</footer>

    
    
        <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.slim.min.js"></script>
        <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
        <script src="https://cdn.bootcss.com/font-awesome/5.9.0/js/all.min.js"></script>
         
            <script type="text/x-mathjax-config">
                MathJax.Hub.Config({
                    CommonHTML: { linebreaks: { automatic: true } },
                    "HTML-CSS": { linebreaks: { automatic: true } },
                    SVG: { linebreaks: { automatic: true } }
                });
            </script>
            <script src='https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
        
    


<script src="/js/av.min.js"></script>
<script src="/js/valine.min.js"></script>
<script src="/js/applause-easy.js"></script>

<script>
$(document).ready(function() {
    var a = new ApplauseEasy({
        id: 'applause-easy',
        appId: "xxxxxxxxxx",
        appKey: "xxxxxxxxxx",
        img_src: "http://img.hanlindong.com/blog/site/clap.png",
        img_width: "50px",
        img_height: "50px"
    })
})
</script>


<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?e8a203f609d8ced2c71c3eee859b6941";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>




    
</body>
</html>