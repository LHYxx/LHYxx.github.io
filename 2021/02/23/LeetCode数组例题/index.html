<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content>
    <link rel="shortcut icon" href="/img/book.png">
    <title>LeetCode数组例题-小新xx</title>
    
        
            <link href="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">
            <link href="https://cdn.bootcss.com/academicons/1.8.6/css/academicons.min.css" rel="stylesheet">
            <link href="https://cdn.bootcss.com/font-awesome/5.9.0/css/all.min.css" rel="stylesheet">
            <link href="https://cdn.bootcss.com/animate.css/3.7.2/animate.min.css" rel="stylesheet">
        
    
    <link rel="stylesheet" href="/css/adagio.css">

    <style type="text/css">
        .jumbotron{
            background: url();
            background-repeat: no-repeat;
            background-size: 100% 100%;
        }
        .tag-list{
            font-weight: bold;
            font-size: 200;
            color: red;
        }
    </style>

<!-- 下面是对mathjax的设置 -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true,
      linebreaks: {automatic: ['\\']}
    },
    "HTML-CSS": { linebreaks: { automatic: true } },
         SVG: { linebreaks: { automatic: true } }
  });
</script>



</head>
<!-- <body style="background: url('/') no-repeat; background-size: 100%;"> 带背景-->
<body>
    <div class="container-fluid">
    <nav class="nav">
        <div class="collapse navbar-collapse" id="navbar-sm">
            
            
            <div class="navbar-nav">
                <a href="/index.html" class="nav-item nav-link">主页</a>
            </div>
            
            <div class="navbar-nav">
                <a href="/others/aboutme.html" class="nav-item nav-link">LHYxx</a>
            </div>
            
        </div>
    </nav>
</div>

<div class="d-flex d-md-none" style="width: 100%; background-color: #e9ecef">
    <div class="nav">
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-sm"
            aria-expanded="false" aria-label="Toggle Navigation">
            <i class="fas fa-bars fa-lg"></i>
        </button>
    </div>
    <nav class="navbar ml-auto">
        <a class="navbar-brand" href="/">
            
            LHYxx
            
        </a>
    </nav>
</div>


<div class="container d-none d-md-block my-navbar">
    <nav class="navbar navbar-expand-sm navbar-light bg-transparent">
        <a class="navbar-brand " href="/">
            
            LHYxx
            
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav"
            aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav">
                
                <li class="nav-item pl-2 pr-2 ">
                    <a class="nav-link" href="/index.html">主页</a>
                </li>
                
                <li class="nav-item pl-2 pr-2 ">
                    <a class="nav-link" href="/others/aboutme.html">LHYxx</a>
                </li>
                
            </ul>
        </div>
    </nav>
</div>




    <div class="jumbotron jumbotron-fluid">
<!-- <div class="jumbotron jumbotron-fluid" style="background-image: url()"> -->
    <div class="container" >
        
        <h1 class="mt-4 article-title page-title" style="font-weight: bold; color: black">LeetCode数组例题</h1>
        
        <p class="lead text-gray mt-3" style="color: black">By 小新; Published on 2021-02-23</p>
        
        <div class="tags">
            <ul class="tag-list">
                
                <li class="tag-list-item">
                    <a class="tag-list-link" href="/tags/leetcode/">leetcode</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</div>
    <div class="container">
        <div class="row">
            <div class="col-md-9 pt-2">
                <div class="row">
                    <div class="col-12">
                        <main>
                            <article class="article-text page-content"><h1 id="LeetCode数组例题"><a href="#LeetCode数组例题" class="headerlink" title="LeetCode数组例题"></a>LeetCode数组例题</h1><p>包含几道LeetCode中数组相关例题。</p>
<h1 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26 删除排序数组中的重复项"></a>26 删除排序数组中的重复项</h1><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>Tips：</p>
<ul>
<li>双指针</li>
</ul>
<p>总结来说就是原地修改数组，删除其中的重复项，并返回移除重复元素后的数组长度。</p>
<p>采用双指针法：</p>
<p>首先快指针i和慢指针j都指向起始元素，因为数组是有序的，因此慢指针j指向当前要填充的位置，快指针i依次递增并最终遍历整个数组，如果有和当前数值（也就是慢指针j指向的数值）不一样的数，则放到慢指针j的下一个位置（j+1），然后令慢指针j指向这个位置（也就是慢指针后移一位）。这样快指针i遍历一遍数组，就可以将所有不重复的元素移动到数组的最前面。因此时间复杂度为O(N)，空间复杂度因为是原地修改，没有使用额外空间，O(N)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        j=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[j]:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">                nums[j]=nums[i]</span><br><span class="line">        <span class="keyword">return</span> j+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="122-买卖股票的最佳时机II"><a href="#122-买卖股票的最佳时机II" class="headerlink" title="122 买卖股票的最佳时机II"></a>122 买卖股票的最佳时机II</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>

<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>Tips：</p>
<ul>
<li>贪心</li>
</ul>
<p>这题千万别分析复杂了，分析复杂就把自己绕进去了。<br>简单的贪心思想：要求整个区间的利益最大，很明显这个区间可以分割成多个子区间，那么每个子区间利益最大，整个区间的利益自然也就最大。那么极端条件下，我们将每天看成一个区间，所以就变成了每天的收益最大即可。<br>每天收益最大：如果股票涨了就卖，收益为正；跌了就不卖，收益为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxProfit(self, prices: List[int]) -&gt; int:</span><br><span class="line">        if len(prices) == 1:</span><br><span class="line">            return 0</span><br><span class="line">        count = 0</span><br><span class="line">        for i in range(1, len(prices)):</span><br><span class="line">            if prices[i] &gt; prices[i-1]:</span><br><span class="line">                count += prices[i]-prices[i-1]</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure>

<h1 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189 旋转数组"></a>189 旋转数组</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>

<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>首先，转一圈等于没转，因此移动位置k需要对数组长度取余。<br>然后我的第一想法是，向右移动k个位置，那么直接把被移出去的k个元素拿过来，拼到剩余数组的前面即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rotate(self, nums: List[int], k: int) -&gt; None:</span><br><span class="line">        length = len(nums)</span><br><span class="line">        k = k % length</span><br><span class="line">        temp = nums[-k:]</span><br><span class="line">        temp.extend(nums[:length-1])</span><br><span class="line">        for i in range(length):</span><br><span class="line">            nums[i] = temp[i]</span><br></pre></td></tr></table></figure>

<p>解题之后看讨论，一种比较神奇的做法是先将整个数组反转，然后反转前半部分，然后反转后半部分。一个可视化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nums = &quot;-----&gt;--&gt;&quot;; k =3</span><br><span class="line">result = &quot;--&gt;-----&gt;&quot;;</span><br><span class="line"></span><br><span class="line">reverse &quot;-----&gt;--&gt;&quot; we can get &quot;&lt;--&lt;-----&quot;</span><br><span class="line">reverse &quot;&lt;--&quot; we can get &quot;--&gt;&lt;-----&quot;</span><br><span class="line">reverse &quot;&lt;-----&quot; we can get &quot;--&gt;-----&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>其他方法可以间<a href="https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/" target="_blank" rel="noopener">官方题解</a>，这里就不赘述了。</p>
<h1 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>这题比较简单，方法也很多。这里记录一种判断是否有重复的小技巧，就是利用集合（set)的无重复特点，直接将数组转换为集合，然后判断集合长度和原数组长度是否相同。相同的话说明没有重复元素，否则说明原数组中有重复元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def containsDuplicate(self, nums: List[int]) -&gt; bool:</span><br><span class="line">        return len(set(nums))!=len(nums)</span><br></pre></td></tr></table></figure>

<h1 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350 两个数组的交集 II"></a>350 两个数组的交集 II</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2,2]</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[4,9]</span><br></pre></td></tr></table></figure>

<p>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。<br>我们可以不考虑输出结果的顺序。</p>
<h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>Tips：</p>
<ul>
<li>排序 + 双指针</li>
</ul>
<p>先将两个数组都进行排序，使其中的元素有序，然后两个指针i，j分别从两个数组的起始开始。<br>如果两个指针指向的元素相同，则添加到新集合中，然后两个指针后移；<br>如果两个指针指向的元素不同，则元素小的那个指针后移，大的不动。<br>当其中一个指针到头了就结束了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:</span><br><span class="line">        nums1.sort()</span><br><span class="line">        nums2.sort()</span><br><span class="line">        intersection = []</span><br><span class="line">        j = 0</span><br><span class="line">        i = 0</span><br><span class="line">        while(i&lt;len(nums1) and j&lt;len(nums2)):</span><br><span class="line">            if nums1[i] == nums2[j]:</span><br><span class="line">                intersection.append(nums1[i])</span><br><span class="line">                i+=1</span><br><span class="line">                j+=1</span><br><span class="line">            elif nums1[i]&lt;nums2[j]:</span><br><span class="line">                i+=1</span><br><span class="line">            else:</span><br><span class="line">                j+=1</span><br><span class="line">        return intersection</span><br></pre></td></tr></table></figure>

<h1 id="66-加一"><a href="#66-加一" class="headerlink" title="66 加一"></a>66 加一</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [1,2,3]</span><br><span class="line">输出：[1,2,4]</span><br><span class="line">解释：输入数组表示数字 123。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [4,3,2,1]</span><br><span class="line">输出：[4,3,2,2]</span><br><span class="line">解释：输入数组表示数字 4321。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [0]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p><strong>第一种直观的方法</strong><br>从最后一位开始看，如果最后一位&lt;9，那么直接最后一位+1即可。<br>麻烦的是进位的情况。<br>从最后一位开始判断，如果是9，就接着看上一位，直到不是9的一位，然后后面的都变成0，不是9的那一位+1即可。<br>如果最后全都是9，那么就都变成0，前面加个1即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def plusOne(self, digits: List[int]) -&gt; List[int]:</span><br><span class="line">        index = len(digits) - 1  # 指针先指向最后一位</span><br><span class="line">        if digits[index]!=9:  # 如果最后一位&lt;9，直接+1即可</span><br><span class="line">            digits[index] += 1</span><br><span class="line">            return digits</span><br><span class="line">        while digits[index]==9 and index&gt;=0:  # 从后往前遍历每一位，当循环退出时，指针指向第一个不是9的那一位。或者如果全是9，指针则为-1。</span><br><span class="line">            index-=1</span><br><span class="line">        if index&lt;0:  # 如果指针为-1，即全是9</span><br><span class="line">            for i in range(0, len(digits)):</span><br><span class="line">                digits[i] = 0</span><br><span class="line">            digits.insert(0, 1)</span><br><span class="line">        else:  # 如果存在不是9的数</span><br><span class="line">            digits[index] += 1</span><br><span class="line">            for i in range(index+1, len(digits)):</span><br><span class="line">                digits[i] = 0</span><br><span class="line">        return digits</span><br></pre></td></tr></table></figure>

<p><strong>还有另外一种方法</strong><br>不需要自己处理进位的情况，那就是把数组中的数转换成真实的int整数，然后+1，然后再转换成数组。这种方法一个问题是如果数太大，比如数组长度几百几千几万的，单个变量可能就爆了，但是测试了一下，在LeetCode上倒是能够通过。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        digits.reverse()</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(digits):</span><br><span class="line">            num += j * (<span class="number">10</span>**i)</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        digits.clear()</span><br><span class="line">        <span class="keyword">while</span> num!=<span class="number">0</span>:</span><br><span class="line">            digits.insert(<span class="number">0</span>, num%<span class="number">10</span>)</span><br><span class="line">            num = num//<span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>

<h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283 移动零"></a>283 移动零</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p>
<h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p>Tips：</p>
<ul>
<li>双指针</li>
</ul>
<p><strong>我的第一种笨拙做法：</strong><br>从头到尾遍历数组，如果是0，就取出来放到数组末尾，并且指针不动（这里如果指针动了就错了，因为取出元素之后，后面的元素位置提前了）；如果不是0，就指针+1。这个方法还得需要一个计数器，统计访问了多少数字了，如果数组中的数全都访问到了，就结束。如果不用计数器的话，因为会将遇到的0移动到最后，所以永远也遍历不完这个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def moveZeroes(self, nums: List[int]) -&gt; None:</span><br><span class="line">        length = len(nums)</span><br><span class="line">        i=0</span><br><span class="line">        count = 0  # 计数器，记录访问的元素数量</span><br><span class="line">        while i&lt;length and count&lt;length:</span><br><span class="line">            if nums[i]==0:</span><br><span class="line">                nums.append(nums.pop(i))  # 将当前元素(0)取出来，添到数组末尾</span><br><span class="line">            else:</span><br><span class="line">                i += 1</span><br><span class="line">            count+=1</span><br><span class="line">        return nums</span><br></pre></td></tr></table></figure>

<p>写完了虽然通过了，但就感觉这代码怎么那么不优雅呢。(<em>/ω＼</em>)。。。。然后就去看人家的题解了。</p>
<p><strong>其中比较喜欢的一种方法（双指针法）：</strong><br>slow指针就指向数组最前面的0，然后fast指针在遍历过程中，如果发现非0元素，就与slow的元素交换。这样fast遍历过一遍数组之后，所有非零元素就都被交换到前面了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def moveZeroes(self, nums: List[int]) -&gt; None:</span><br><span class="line">        fast = 0</span><br><span class="line">        slow = 0</span><br><span class="line">        while fast&lt;len(nums):</span><br><span class="line">            if nums[fast] != 0:</span><br><span class="line">                nums[fast], nums[slow] = nums[slow], nums[fast]</span><br><span class="line">                slow += 1</span><br><span class="line">            fast += 1</span><br></pre></td></tr></table></figure>

<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1 两数之和"></a>1 两数之和</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>你可以按任意顺序返回答案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;= nums.length &lt;= 103</span><br><span class="line">-109 &lt;= nums[i] &lt;= 109</span><br><span class="line">-109 &lt;= target &lt;= 109</span><br><span class="line">只会存在一个有效答案</span><br></pre></td></tr></table></figure>

<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<h2 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h2><p>Tips</p>
<ul>
<li>哈希表</li>
</ul>
<p>这题基础方法可以采用一个双层循环暴力搜索即可。<br>但是一种比较高效的方法是采用哈希表。<br>对每个元素x，如果target-x没在哈希表中，则将x记录在哈希表中。<br>如果对某个元素y，如果target-y在哈希表中，说明元素y和target-y加起来等于target，所以这两个元素之和就是target，返回他们的下标即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if target-nums[i] not in dic:</span><br><span class="line">                dic[nums[i]] = i</span><br><span class="line">            else:</span><br><span class="line">                return [dic[target-nums[i]], i]</span><br></pre></td></tr></table></figure>

<h1 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36 有效的数独"></a>36 有效的数独</h1><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 1-9 在每一行只能出现一次。</li>
<li>数字 1-9 在每一列只能出现一次。</li>
<li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br><img src="36.png" alt="36有效的数独"><br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</li>
</ol>
<p>示例 1:</p>
<p>输入:<br>[<br>  [“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>输出: true</p>
<p>说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个有效的数独（部分已被填充）不一定是可解的。</span><br><span class="line">只需要根据以上规则，验证已经填入的数字是否有效即可。</span><br><span class="line">给定数独序列只包含数字 1-9 和字符 &apos;.&apos; 。</span><br><span class="line">给定数独永远是 9x9 形式的。</span><br></pre></td></tr></table></figure>

<h2 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h2><p>我的初始解法<br>用三个哈希表分别判断行是否满足(rowdic)、列是否满足(coldic)、块是否满足(blockdic)。<br>其中，行哈希表记录每个数字出现的行号：(1:[1, 2, 3])表示数字1出现在了第1, 2, 3行；类似的，列哈希表记录每个数字出现的列号，块哈希表记录每个数字出现的块号。<br>其中，块号的计算方式为：i//3 * 3 + j//3。其中i为行号，j为列号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getBlock</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (i//<span class="number">3</span>)*<span class="number">3</span> + j//<span class="number">3</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">        rowdic = &#123;&#125;</span><br><span class="line">        coldic = &#123;&#125;</span><br><span class="line">        blockdic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[i])):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'.'</span>:  <span class="comment"># 如果元素为空，则跳过</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 判断行</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] <span class="keyword">not</span> <span class="keyword">in</span> rowdic:</span><br><span class="line">                    rowdic[board[i][j]] = [i]</span><br><span class="line">                <span class="keyword">elif</span> i <span class="keyword">in</span> rowdic[board[i][j]]:  <span class="comment"># 如果有重复的行号，说明不成立</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    rowdic[board[i][j]].append(i)</span><br><span class="line">                <span class="comment"># 判断列</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] <span class="keyword">not</span> <span class="keyword">in</span> coldic:</span><br><span class="line">                    coldic[board[i][j]] = [j]</span><br><span class="line">                <span class="keyword">elif</span> j <span class="keyword">in</span> coldic[board[i][j]]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    coldic[board[i][j]].append(j)</span><br><span class="line">                <span class="comment"># 判断块</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] <span class="keyword">not</span> <span class="keyword">in</span> blockdic:</span><br><span class="line">                    blockdic[board[i][j]] = [self.getBlock(i,j)]</span><br><span class="line">                <span class="keyword">elif</span> self.getBlock(i,j) <span class="keyword">in</span> blockdic[board[i][j]]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    blockdic[board[i][j]].append(self.getBlock(i,j))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>另一种方法用三个矩阵来分别记录行、列、块是否满足。<br>row、col、box分别为9x9的矩阵，其中row[i][j]表示第i行的数字j是否出现过，如果row[i][j]=0表示数字j没有在第i行出现过，反之，如果row[i][j]=1则表示数字j在第i行出现过。col矩阵与box矩阵也是同理。<br>所以在遍历整个数独矩阵时，如果出现过就将相应位置变为1，如果在某个位置出现了冲突，则说明数独不成立。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        row = [[<span class="number">0</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        col = [[<span class="number">0</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        box = [[<span class="number">0</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'.'</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                curNum = ord(board[i][j]) - ord(<span class="string">'0'</span>)</span><br><span class="line">                <span class="keyword">if</span> row[i][curNum] != <span class="number">0</span> <span class="keyword">or</span> col[j][curNum] != <span class="number">0</span> <span class="keyword">or</span> box[j // <span class="number">3</span> + (i // <span class="number">3</span>) * <span class="number">3</span>][curNum] != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                row[i][curNum], col[j][curNum],box[j // <span class="number">3</span> + (i // <span class="number">3</span>) * <span class="number">3</span>][curNum] = <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>人家的代码总是那么简洁优雅o(╥﹏╥)o</p>
<h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48 旋转图像"></a>48 旋转图像</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">matrix.length == n</span><br><span class="line">matrix[i].length == n</span><br><span class="line">1 &lt;= n &lt;= 20</span><br><span class="line">-1000 &lt;= matrix[i][j] &lt;= 1000</span><br></pre></td></tr></table></figure>

<p>示例1：<br><img src="48.jpg" alt="48"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure>

<h2 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h2><p>这题找一下规律：<br>旋转90度，等于先对矩阵进行转置，然后左右翻转一下。找到规律就好说了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rotate(self, matrix: List[List[int]]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify matrix in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        n = len(matrix)</span><br><span class="line">        for i in range(n):</span><br><span class="line">            for j in range(i, n):</span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class="line">            matrix[i].reverse()</span><br></pre></td></tr></table></figure>

<h1 id="766-托普利茨矩阵"><a href="#766-托普利茨矩阵" class="headerlink" title="766 托普利茨矩阵"></a>766 托普利茨矩阵</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 m x n 的矩阵 matrix 。如果这个矩阵是托普利茨矩阵，返回 true ；否则，返回 false 。</p>
<p>如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 托普利茨矩阵 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m == matrix.length</span><br><span class="line">n == matrix[i].length</span><br><span class="line">1 &lt;= m, n &lt;= 20</span><br><span class="line">0 &lt;= matrix[i][j] &lt;= 99</span><br></pre></td></tr></table></figure>

<p>示例1：<br><img src="766.jpg" alt="766"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">9</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">在上述矩阵中, 其对角线为: </span><br><span class="line"><span class="string">"[9]"</span>, <span class="string">"[5, 5]"</span>, <span class="string">"[1, 1, 1]"</span>, <span class="string">"[2, 2, 2]"</span>, <span class="string">"[3, 3]"</span>, <span class="string">"[4]"</span>。 </span><br><span class="line">各条对角线上的所有元素均相同, 因此答案是 <span class="literal">True</span> 。</span><br></pre></td></tr></table></figure>

<h2 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h2><p>Tips：</p>
<ul>
<li>哈希表</li>
</ul>
<p>又到了找规律的时候。<br>托普利茨矩阵 的特征就是：行列差相等的位置，元素相同。<br>例如i行j列，m行n列的元素，如果有i-j=m-n，必有matrix[i][j]=matrix[m][n]。<br>所以用哈希表存储（行列差：元素值）判断是否都相等即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isToeplitzMatrix</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[i])):</span><br><span class="line">                <span class="keyword">if</span> (i-j) <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                    dic[i-j] = matrix[i][j]</span><br><span class="line">                <span class="keyword">elif</span> matrix[i][j] != dic[i-j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></article>
                        </main>
                        
                        
                    </div>
                </div>
                <div class="row mt-5 mb-5">
                    <div class="col-12">
                        <div class="row">
    <div class="col">
        <nav aria-label="paginator" class="paginator">
            <ul class="pagination d-none d-md-flex pagination-lg justify-content-center">
                <li class="page-item ">
                    <a class="page-link"
                        href="/2021/02/24/LeetCode1052-爱生气的图书馆老板/"
                        aria-label="Previous">
                        <span aria-hidden="true">&laquo;
                            LeetCode1052 爱生气的图书馆老板</span>
                        <span class="sr-only">Previous</span>
                    </a>
                </li>
                <li class="page-item ">
                    <a class="page-link"
                        href="/2021/02/19/Docker学习记录/"
                        aria-label="Next">
                        <span
                            aria-hidden="true">Docker学习记录
                            &raquo;</span>
                        <span class="sr-only">Next</span>
                    </a>
                </li>
            </ul>
            <ul class="pagination d-md-none justify-content-center">
                <li class="page-item ">
                    <a class="page-link"
                        href="/2021/02/24/LeetCode1052-爱生气的图书馆老板/"
                        aria-label="Previous">
                        <span aria-hidden="true">&laquo;
                            LeetCode1052 爱生气的图书馆老板</span>
                        <span class="sr-only">Previous</span>
                    </a>
                </li>
                <li class="page-item ">
                    <a class="page-link"
                        href="/2021/02/19/Docker学习记录/"
                        aria-label="Next">
                        <span
                            aria-hidden="true">Docker学习记录
                            &raquo;</span>
                        <span class="sr-only">Next</span>
                    </a>
                </li>
            </ul>
        </nav>
    </div>
</div>



                    </div>
                </div>
                <div class="row">
                    <div class="col-12">
                        <div id="vcomment"></div>
                    </div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="container pt-4 page-sidebar">
                    
                    <div class="row">
    <div class="col">
        <h6>APPLAUSE FOR ME</h6>
        <div id="applause-easy"></div>
    </div>
</div>
                    
                    <hr class="row">
                    <div class="row toc-container">
                        <div class="col-12">
                            <h6>NAVIGATION</h6>
                            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#LeetCode数组例题"><span class="toc-text">LeetCode数组例题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26-删除排序数组中的重复项"><span class="toc-text">26 删除排序数组中的重复项</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#问题描述："><span class="toc-text">问题描述：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#122-买卖股票的最佳时机II"><span class="toc-text">122 买卖股票的最佳时机II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-1"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#189-旋转数组"><span class="toc-text">189 旋转数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-2"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#217-存在重复元素"><span class="toc-text">217. 存在重复元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-3"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#350-两个数组的交集-II"><span class="toc-text">350 两个数组的交集 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-4"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#66-加一"><span class="toc-text">66 加一</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-5"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#283-移动零"><span class="toc-text">283 移动零</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-6"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-两数之和"><span class="toc-text">1 两数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-6"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-7"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#36-有效的数独"><span class="toc-text">36 有效的数独</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-8"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#48-旋转图像"><span class="toc-text">48 旋转图像</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-7"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-9"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#766-托普利茨矩阵"><span class="toc-text">766 托普利茨矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-8"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-10"><span class="toc-text">题解</span></a></li></ol></li></ol>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <footer>
    <div class="jumbotron jumbotron-fluid mb-0">
        <div class="container-fluid">
            <div class="col text-center">
                <div class="bottom-social">
                    <div class="row">
    <div class="col text-center">
        <ul class="list-inline">
            
            <li class="list-inline-item">
                
                <a href="https://github.com/LHYxx">
                    <span class="fa-stack fa-2x icon-link">
                        <i class="fas fa-circle fa-stack-2x"></i>
                        <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                    </span>
                </a>
                
            </li>
            
            <li class="list-inline-item">
                
                <a href="https://www.zhihu.com/people/zhihu_name">
                    <span class="fa-stack fa-2x icon-link">
                        <i class="fas fa-circle fa-stack-2x"></i>
                        <i class="fab fa-zhihu fa-stack-1x fa-inverse"></i>
                    </span>
                </a>
                
            </li>
            
        </ul>
    </div>
</div>

                </div>
                <p class="copyright text-muted">
                    Copyright &copy; 小新xx
                    <br>
                    感谢支持！
                    <br>
                    <a href="http://cs.scu.edu.cn/">海纳百川</a>, 
                    <a href="http://www.tju.edu.cn/">实事求是</a>.
                </p>
            </div>
        </div>
    </div>
</footer>

    
    
        <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.slim.min.js"></script>
        <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
        <script src="https://cdn.bootcss.com/font-awesome/5.9.0/js/all.min.js"></script>
         
            <script type="text/x-mathjax-config">
                MathJax.Hub.Config({
                    CommonHTML: { linebreaks: { automatic: true } },
                    "HTML-CSS": { linebreaks: { automatic: true } },
                    SVG: { linebreaks: { automatic: true } }
                });
            </script>
            <script src='https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
        
    


<script src="/js/av.min.js"></script>
<script src="/js/valine.min.js"></script>
<script src="/js/applause-easy.js"></script>

<script>
$(document).ready(function() {
    var a = new ApplauseEasy({
        id: 'applause-easy',
        appId: "xxxxxxxxxx",
        appKey: "xxxxxxxxxx",
        img_src: "http://img.hanlindong.com/blog/site/clap.png",
        img_width: "50px",
        img_height: "50px"
    })
})
</script>


<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?e8a203f609d8ced2c71c3eee859b6941";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>




    
</body>
</html>